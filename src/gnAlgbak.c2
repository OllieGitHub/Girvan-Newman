#include "readgml.h"
#include "stdlib.h"

int main()
{
	VERTEXNODE * head;
	VERTEXNODE * tail;
	VERTEXNODE * temp;
	DEL_ORDER *delOrder;
	NETWORK    *network = NULL;
	FILE 	   *fp;
	int 	   delOrderSize = 0,
			   edgeIdx,
			   orderIdx = 0,
			   i,
			   k;

	network  = (NETWORK*) malloc(sizeof(NETWORK));
	fp = fopen("./test.gml", "r");

	if (fp == NULL)
	{
	  fprintf(stderr, "Can't open input file\n");
	  exit(1);
	}

	//parse file into NETWORK structure
	read_network(network,fp);
	//will realloc as necessary
	delOrderSize = network->nvertices;
	delOrder = (DEL_ORDER *) malloc(delOrderSize * sizeof(DEL_ORDER));


	for (i = 0; i < network->nvertices;i++)
	{
		head = (VERTEXNODE *) malloc(sizeof(VERTEXNODE));
		temp = (VERTEXNODE *) malloc(sizeof(VERTEXNODE));

		//init head to root
		head->vertexIdx = i;
		//mark root visited and prime depth
		network->vertex[head->vertexIdx].visited = 1;
		network->vertex[head->vertexIdx].bfsLevel = 0;
		head->prev = NULL;
		tail = head;

		if (0 == network->vertex[head->vertexIdx].degree)
		{
			head->next = NULL;
		}
		while (head)
		{
			//add nodes not visited to list
			for (k = 0; k < network->vertex[head->vertexIdx].degree; k++)
			{
				edgeIdx = network->vertex[head->vertexIdx].edge[k].target;
				if (0 == network->vertex[edgeIdx].visited)
				{
					tail->next = malloc(sizeof(VERTEXNODE));
					(tail->next)->prev = tail;
					tail = tail->next;
					tail->next = NULL;
					tail->vertexIdx = edgeIdx;
					//mark visited
					network->vertex[tail->vertexIdx].visited = 1;
					network->vertex[tail->vertexIdx].flowAvail = 1;
					//compute BFS
					network->vertex[tail->vertexIdx].bfsLevel = network->vertex[head->vertexIdx].bfsLevel + 1;

					if(1 == network->vertex[tail->vertexIdx].bfsLevel)
					{
						network->vertex[tail->vertexIdx].shortPaths = 1;
					}
				}
				//compute shortest path
				if (network->vertex[head->vertexIdx].bfsLevel > network->vertex[edgeIdx].bfsLevel)
				{
					network->vertex[head->vertexIdx].shortPaths += network->vertex[edgeIdx].shortPaths;
				}
			}
			printf("%d->%d:%d    ", network->vertex[head->vertexIdx].id,
									network->vertex[head->vertexIdx].bfsLevel,
									network->vertex[head->vertexIdx].shortPaths);
			//remove head of list
			head = head->next;
		}

		//go back through the list to the root node
		head = tail;

		printf("\n\n");
		while(head)
		{
			for (k = 0; k < network->vertex[head->vertexIdx].degree; k++)
			{
				edgeIdx = network->vertex[head->vertexIdx].edge[k].target;
				//get the ratio of flow that should be sent to each node that has BFS level lower than
				//current nodes BFS (flow should only go up, not sideways or down)
				if(network->vertex[edgeIdx].bfsLevel < network->vertex[head->vertexIdx].bfsLevel)
				{
					//the flow of the edge is the flow available from the lower node times the ratio of shortest paths
					network->vertex[head->vertexIdx].edge[k].flow = ((network->vertex[head->vertexIdx].flowAvail) *
																	((double)(network->vertex[edgeIdx].shortPaths) /
																    ((double)network->vertex[head->vertexIdx].shortPaths)));

					if (0 == network->vertex[edgeIdx].bfsLevel)
					{
						//our edge is the root, send all flow available
						network->vertex[head->vertexIdx].edge[k].flow = network->vertex[head->vertexIdx].flowAvail;
					}
					else
					{
						//our edge is not the root, calculate how much flow we are able to send after the additional flow is
						//received from the edge[k]
						network->vertex[edgeIdx].flowAvail += network->vertex[head->vertexIdx].edge[k].flow;
					}
					//sum up edge flows
					network->vertex[head->vertexIdx].edge[k].flowSum += (network->vertex[head->vertexIdx].edge[k].flow);

					printf("W: %02d<->%02d = %.2f, %.2f\n", network->vertex[head->vertexIdx].id,
												   network->vertex[edgeIdx].id,
												   network->vertex[head->vertexIdx].edge[k].flow,
												   network->vertex[head->vertexIdx].edge[k].flowSum);
				}

			//	if ((network->nvertices-1) == i)
				//{
					if ((orderIdx + 1) > delOrderSize)
					{
						delOrderSize = delOrderSize*2;
						delOrder = (DEL_ORDER *) realloc(delOrder, (delOrderSize*2) * sizeof(DEL_ORDER));
					}
					//if (network->vertex[head->vertexIdx].bfsLevel <= network->vertex[edgeIdx].bfsLevel)
					//{
						delOrder[orderIdx].flow = network->vertex[head->vertexIdx].edge[k].flowSum;
						delOrder[orderIdx].vertex1 = network->vertex[head->vertexIdx].id;
						delOrder[orderIdx++].vertex2 = network->vertex[edgeIdx].id;
					//}
				//}
			}
			temp = head->prev;
			//cleanup on the way out
			free(head);
			head = temp;
		}

		for (k = 0; k < network->nvertices;k++)
		{
			network->vertex[k].visited = 0;
			network->vertex[k].shortPaths = 0;
		}

		free(temp);
		printf("\n");
	}

	qsort(delOrder,(orderIdx),sizeof(DEL_ORDER),(void*)cmpBtwn);

	//for (i = 0; i < orderIdx; i+=2)
	//{
		printf("%2d:  %2d <->%2d = %f\n", 1, delOrder[0].vertex1, delOrder[0].vertex2, delOrder[0].flow);
	//}

	free_network(network);
}

//compare edge flows
int cmpBtwn(DEL_ORDER *e1, DEL_ORDER *e2)
{
  if (e1->flow < e2->flow) return 1;
  if (e1->flow > e2->flow) return -1;
  return 0;
}
